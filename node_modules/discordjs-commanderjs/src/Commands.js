const Discord = require('discord.js');
const fs = require('fs');
const path = require('path');
const root = path.dirname(require.main.filename || process.mainModule.filename);

class Commands {

    constructor (client, ownerID) {
        this.commands = new Discord.Collection();
        this.client = client;
        this.ownerID = ownerID;
    }

    add (command) {
        this.commands.set(this.commands.size, command);
    }

    addCommand (command) {
        this.add(command);
    }

    addCommandWithDirectory (dir) {
        fs.readdir(dir, (err, items) => {
            if (items.length === 0) throw(`${dir} directory is empty`);

            for (let i=0; i < items.length; i++) {
                let clas = require(root + '/' + dir + '/' + items[i]);
                this.add(new clas());
            }
        })
    }

    isCommand (command) {
        return this.commands.find(c => c.match(command) === true);
    }

    callUnknownCommand(message, args, option) {
        let unknownCommmand = this.commands.find(c => c.unknown === true);
        if (unknownCommmand === undefined) return;
        this.call(unknownCommmand.name, message, args, option);
    }

    call (command, message, args, option) {
        /**
         * @type {Command}
         */
        let cmdClass = this.commands.find(c => c.match(command) === true);
        if (cmdClass.ownerOnly && cmdClass.ownerOnly.bot) if (message.author.id !== this.ownerID) return;
        if (cmdClass.ownerOnly && cmdClass.ownerOnly.guild) if (message.author.id !== message.guild.ownerID) return;
        if (cmdClass.guildOnly) if (message.channel.type !== 'text') return;
        if (!cmdClass.hasPermissions(this.client, message)) return;
        if (!cmdClass.throttle(message)) return;
        if (cmdClass.commandHelp) option.commands = this.commands;
        cmdClass.run(message, args, option);
    }

}

module.exports = Commands;